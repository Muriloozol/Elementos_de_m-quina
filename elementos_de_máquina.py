# -*- coding: utf-8 -*-
"""Elementos_de_Máquina.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EDyIRUSHlKVRKCrpT2C8GtoUkXOfeAaV

# Elementos de Máquina
Professor: 
- Rodrigo de Souza Vieira, email: rodrigo.vieira@ufsc.br

Alunos:
- Thiago Pessoa
- Murilo Ozol

Outras informações
- [Ementa](https://moodle.ufsc.br/pluginfile.php/3279712/mod_resource/content/9/programa.pdf)

## Descrição do Trabalho
Nesta disciplina é proposto a realização de um Projeto de redutor como forma de aplicar as metodologias de ensino *learning by doing* e *flip class*. O projeto será dividido em etapas bem definidas de acordo com os elementos de máquina a serem abordados. A seguinte sequência será seguida:

1. Projeto dos pares de engrenagens
2. Definição da correia ou corrente no eixo de saída do redutor
  1. Distância entre centros de 480 mm
  2. Relação de desmultiplicação de 1:3,2
3. Projeto dos eixos
4. Projeto da Ligação cubo eixo entre as peças

### Motivação para utilização do google colab
"""

import numpy as np
import pandas as pd
import regex as re
import json
import matplotlib.pyplot as plt

"""### Projeto sorteado
1º Projeto

Redutor de dois estágios

- Rotação na entrada: 1750 rpm
- Rotação de saída: 110 rpm
- Distância entre centros 238 mm
- Potência do motor 45 CV

**Primeiros Cálculos**
"""

rpm_in = 1750 # rpm
rpm_out = 110 # rpm
a = 238 # mm (distância entre centros)
pot_engine = 45 # CV
pot_engine = pot_engine * 745.7 # W

# Relação de transmissão total
i_t = rpm_in/rpm_out

i_t_error = np.abs(-i_t*0.01)

# Torque
T = (pot_engine * 30000 * 0.101972)/(np.pi*rpm_in) # kgfmm

print('A relação de transmissão total é {}'.format(np.round(i_t, 2)))
print('O torque na entrada é {} kgfmm'.format(np.round(T,2)))

"""## Recomendações de Projeto

#### **Recomendação de relação de transmissão**

>$i_1=0,71i_t^{0.7}$

>$i_t = i_1*i_2$
"""

# Relações de transmissão para os dois estágios
i_1 = 0.71*i_t**0.7 
i_2 = i_t/i_1

print('A relação de transmissão do primeiro par é: {}'.format(np.round(i_1,2)))
print('A relação de transmissão do segundo par é: {}'.format(np.round(i_2,2)))

"""#### **Pré-dimensionamento baseado no colapso por fadiga superficial**
>$d_1'= sqrt[3]{4T_1(i+1)\over iy_M\Psi_d}$

Onde,

- $d_1'$ -> o diâmetro primitivo do pinhão em $mm$
- $T_1$  -> torque de entrada em $kgfmm$
- $y_M$  -> fator MAAG (dado na tabela 10.3 em $kgf/mm^2$
- $i$    -> Relação de transmissão
- $\Psi_d$ -> Relação entre largura e diâmetro

> $\Psi_d = \frac{b}{d}$

O Módulo pode ser calculado por
> $m = \frac{d_1'}{Z_1}$

Onde,
- $Z_1$ -> Numero de dentes

**Parâmetros**

Valores iniciais tirados de tabelas propostas pela literatura
"""

y_m = 0.8
Psi_d_1 = 0.5
Psi_d_2 = 0.5

"""**Primeiro par**"""

# Apply the equation for the first pair
d1_1 = ((4*T*(i_1+1))/(i_1*y_m*Psi_d_1))**(1/3)
d2_1 = i_1*d1_1

print('Diâmetro do pinhão do primeiro par: {}mm'.format(np.round(d1_1,2)))
print('Diâmetro da coroa do primeiro par: {}mm'.format(np.round(d2_1,2)))
print('A distância entre centros é: {}mm'.format(np.round((d1_1+d2_1)/2, 2)))

"""**Segundo par**"""

# Apply the equation for the second pair
d1_2 = ((4*T*(i_2+1))/(i_2*y_m*Psi_d_2))**(1/3)
d2_2 = i_2*d1_2

print('Diâmetro do pinhão do segundo par: {}mm'.format(np.round(d1_2,2)))
print('Diâmetro da coroa do segundo par: {}mm'.format(np.round(d2_2,2)))
print('A distância entre centros é: {}mm'.format(np.round((d1_2+d2_2)/2, 2)))

"""####**Otimizando o parâmetro $\Psi_d$**"""

def calculate_a_error(i_1, i_2, Psi_d_1, Psi_d_2, y_m=0.8, a=238):
    """
    Calculate the `a` error given the parameters to apply on the recomendation
    equation.

    Parameters
    ----------
        i_1: float
            first pair gear ratio
        
        i_2: float
            second pair gear ratio
        
        Psi_d_1: float
            Relation between width and diameter
        
        Psi_d_2: float
            Relation between width and diameter
        
        y_m: float, default=0.8
            Maag factor
        
        a: float or int
            Desired distance between axis

    Returns
    -------
        error: float
            Sum of `error_1` and `error_2`
        
        error_1: float
            Calculated a and `a` desired difference 
        
        error_2: float
            Calculated a and `a` desired difference 
    """
    # Apply the recomendation equation
    d1_1 = ((4*T*(i_1+1))/(i_1*y_m*Psi_d_1))**(1/3)
    d2_1 = i_1*d1_1

    d1_2 = ((4*T*(i_2+1))/(i_2*y_m*Psi_d_2))**(1/3)
    d2_2 = i_2*d1_2

    # Calculated distance between axis
    a_1 = np.round((d1_1+d2_1)/2, 2)
    a_2 = np.round((d1_2+d2_2)/2, 2)
    
    # Error from both axis
    error_1 = a - a_1
    error_2 = a - a_2
    
    # Total error
    error = np.abs(error_1) + np.abs(error_2)
    
    return error, error_1, error_2

# Dict to hold the results
result = {'y_m':y_m, 
          'Psi_d_1': np.infty,
          'Psi_d_2': np.infty,
          'error': np.infty, 
          'error_1': np.infty,
          'error_2': np.infty}

# Lists to compute the errors
error_list = []
error_1_list = []
error_2_list = []

# Iteration over the Psi_d_1 for the first pair
for Psi_d_1_ in np.linspace(0.1, 1.2, 50):
    # Iteration over the Psi_d_1 for the second pair
    for Psi_d_2_ in np.linspace(0.01, 1.2, 50):   
        # Calculate the errors
        error, error_1, error_2 = calculate_a_error(i_1=i_1, i_2=i_2,
                                                    Psi_d_1=Psi_d_1_,
                                                    Psi_d_2=Psi_d_2_)
        
        # Verify if the error is smaller than the last computed
        if error < result['error']:
            # Compute the results
            result.update({'y_m':y_m, 
                           'Psi_d_1': Psi_d_1_, 
                           'Psi_d_2': Psi_d_2_, 
                           'error': error,
                           'error_1': error_1, 
                           'error_2': error_2})
            
            # Compute the errors
            error_list.append(error)
            error_1_list.append(error_1)
            error_2_list.append(error_2)

            # Override the last Psi_d
            Psi_d_1 = Psi_d_1_
            Psi_d_2 = Psi_d_2_

result

plt.title('Convergência na distância entre eixos')
plt.plot(error_list, label='Erro total')
plt.plot(error_1_list, label='Erro do par 1')
plt.plot(error_2_list, label='Erro do par 2')
plt.xlabel('Iterações')
plt.ylabel('Erro em relação a distância\n entre centros \n[mm]')
plt.legend()
plt.grid()
plt.show()

"""Reaplicando a equação de pré-dimensionamento utilizando os valores de $\Psi_d$ otimizados.

**Primeiro par**
"""

d1_1 = ((4*T*(i_1+1))/(i_1*y_m*Psi_d_1))**(1/3)
d2_1 = i_1*d1_1

print('Diâmetro do pinhão do primeiro par: {}mm'.format(np.round(d1_1,2)))
print('Diâmetro da coroa do primeiro par: {}mm'.format(np.round(d2_1,2)))
print('A distância entre centros é: {}mm'.format(np.round((d1_1+d2_1)/2, 2)))

"""**Segundo par**"""

d1_2 = ((4*T*(i_2+1))/(i_2*y_m*Psi_d_2))**(1/3)
d2_2 = i_2*d1_2

print('Diâmetro do pinhão do segundo par: {}mm'.format(np.round(d1_2,2)))
print('Diâmetro da coroa do segundo par: {}mm'.format(np.round(d2_2,2)))
print('A distância entre centros é: {}mm'.format(np.round((d1_2+d2_2)/2, 2)))

"""#### **Definindo o número mínimo de dentes**

Para não haver recorte, o número mínimo de dentes é dado por:
>$Z_{min} = {2K\over \sin^2\alpha}$

onde,
- $K=1+c$ 
- $c$ é o fator de folga de fundo e $c_{padrão}=0.25$ 

$\alpha$ é o ângulo de pressão e pode assumir os seguintes valores:
- $14.5^o$
- $20^o$ -> Mais utilizado
- $25^o$
"""

c = 0.25
alpha = np.pi/9

Z_min = 2*(1+c)/(np.sin(alpha)**2)
Z_min = np.ceil(Z_min)

print(Z_min)

"""#### **Definição do módulo**

Considerando que nosso par de engrenagens é de uso geral, usaremos um módulo padronizado de classe I. O seguinte conjunto apresenta os módulos de classe I padronizados pela norma ABNT PB-90
> $	\left \{ 0.3, 0.4, 0.5, 0.6, 0.8, 1, 1.25, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10, 12, 20,25,32,40,50 \right \}$

De acordo com a definição de módulo $m = {d_1'\over Z_1}$ podemos encontrar uma estimativa utilizando o valor do diâmetro apresentado anteriormente e o número mínimo de dentes.
"""

m_list = [0.3, 0.4, 0.5, 0.6, 0.8, 1, 1.25, 1.5, 2, 2.5,
          3, 4, 5, 6, 8, 10, 12, 20, 25, 32, 40, 50]

m = d1_1/Z_min

print('A primeira estimativa de módulo utilizando o número mínimo de \
dentes foi: {}mm'.format(np.round(m, 2)))

"""Verifica-se o número de dentes de todas as engrenagens utilizando o módulo padronizado mais próximo do valor encontrado."""

def verify_rounded_m(m, d1_1, d2_1, d1_2, d2_2):
    """
    With the given diameteres and modulus, calculate the number of teeth,
    the gear ratio for the pairs and the total.

    Parameters
    ----------
    m: `int` or `float`
        modulus to verify

    d1_1: `float`
        First gear of first pair diameter

    d2_1: `float`
        Second gear of first pair diameter

    d1_2: `float`
        First gear of second pair diameter

    d2_2: `float`
        Second gear of second pair diameter

    Returns
    -------
    Dict
        Dictionary with `modulo`, `Z1_1`, `Z2_1`, `Z1_2`, `Z2_2`, `i_1`, `i_2`
        and `i_t` data
    """
    m=m

    # Calculate the number of teeth
    Z1_1 = np.round(d1_1/m)
    Z2_1 = np.round(d2_1/m)
    Z1_2 = np.round(d1_2/m)
    Z2_2 = np.round(d2_2/m)

    # Calculate the gear ratio
    i_1 = Z2_1/Z1_1
    i_2 = Z2_2/Z1_2
    i_t = i_1 * i_2


    return {'modulo': m, 
            'Z1_1':Z1_1,
            'Z2_1':Z2_1, 
            'Z1_2':Z1_2,
            'Z2_2':Z2_2,
            'i_1':i_1, 
            'i_2':i_2,
            'i_t':i_t}


verified = verify_rounded_m(m=np.round(m), d1_1=d1_1, d2_1=d2_1, d1_2=d1_2, d2_2=d2_2)

print('O módulo padronizado: {}mm \n'.format(verified['modulo']))

print('Número de dentes do pinhão da engrenagem do primeiro par: \t{}'\
    .format(verified['Z1_1']))
print('Número de dentes da coroa da engrenagem do primeiro par: \t{}'\
    .format(verified['Z2_1']))
print('Número de dentes do pinhão da engrenagem do segundo par: \t{}'\
    .format(verified['Z1_2']))
print('Número de dentes da coroa da engrenagem do segundo par: \t{}\n'\
    .format(verified['Z2_2']))

print('Nova relação de transmissão do par 1: \t{}'.format(verified['i_1']))
print('Nova relação de transmissão do par 2: \t{}'.format(verified['i_2']))
print('Nova relação de transmissão total: \t{}\n'.format(verified['i_t']))

"""Tendo em vista o número excessivo de dentes nas coroas, testaremos outros módulos."""

# DataFrame to hold results
modulus_df = pd.DataFrame(columns=['modulo',
                                   'Z1_1', 'Z2_1', 
                                   'Z1_2', 'Z2_2', 
                                   'i_1', 'i_2', 'i_t'])

# Iterate over standard modulus
for i in m_list:
    r = verify_rounded_m(m=i, d1_1=d1_1, d2_1=d2_1, d1_2=d1_2, d2_2=d2_2)
    modulus_df = modulus_df.append(r, ignore_index=True)

modulus_df

"""Podemos agora, verificar qual destas opções possui o menor desvio na relação de transmissão total."""

modulus_df['Erro [%]'] = np.abs((modulus_df['i_t']-i_t)/i_t)*100
modulus_df.sort_values('Erro [%]')

"""O próximo requisito a ser verificado é o número de dentes total."""

modulus_df['Soma de dentes'] = modulus_df.loc[:,'Z1_1':'Z2_2'].sum(axis=1)
modulus_df.sort_values('Soma de dentes', ascending=False)

"""Tendo em vista que algumas opções apresentam número excessivo de dentes e outras um número extremamente reduzido, eliminaremos as opções cuja soma de dentes seja maior que $250$ e qualquer opção que apresente alguma engrenagem com número de dentes inferior a $4$."""

modulus_df = modulus_df[modulus_df['Soma de dentes']<250]
modulus_df = modulus_df[modulus_df['Z1_1']>4] 
modulus_df

"""Tendo em vista que o erro percentual é $>1\%$ em todas as opções restantes, tentaremos ajustar o número de dentes, mantendo os módulos padronizados, de forma que o erro seja menor que o aceitável."""

d1_1_ = modulus_df['modulo'] * modulus_df['Z1_1']
d2_1_ = modulus_df['modulo'] * modulus_df['Z2_1']
d1_2_ = modulus_df['modulo'] * modulus_df['Z1_2']
d2_2_ = modulus_df['modulo'] * modulus_df['Z2_2']

a_1_ = (d1_1_ + d2_1_)/2
a_2_ = (d1_2_ + d2_2_)/2

modulus_df['a_1'] = a_1_
modulus_df['a_2'] = a_2_
modulus_df

opt_df = pd.DataFrame(columns=['modulo',
                               'Z1_1', 'Z2_1', 
                               'Z1_2', 'Z2_2',
                               'd1_1', 'd2_1',
                               'd1_2', 'd2_2', 
                               'i_1', 'i_2', 'i_t',
                               'Erro [%]', 'Soma de dentes',
                               'a_1', 'a_2'])

for m_ in modulus_df['modulo']:
    for i in range(15,30):                 # Z1_1
        for j in range(30,105):            # Z2_1
            for k in range(15,30):         # Z1_2
                for l in range(30,120):    # Z2_2
                    Z_sum_ = i+j+k+l 
                    if Z_sum_ < 250:
                        
                        d1_1_ = i * m_
                        d2_1_ = j * m_
                        d1_2_ = k * m_
                        d2_2_ = l * m_

                        a_1_ = (d1_1_ + d2_1_)/2
                        a_2_ = (d1_2_ + d2_2_)/2

                        if np.abs(a_1_-a)<5 and np.abs(a_2_-a)<5:
                            
                            i_t_ = j/i * l/k
                            error_ = np.abs((i_t-i_t_)*100/i_t)
                            
                            if error_<1:
                            
                                r = {'modulo':m_,
                                     'Z1_1':i,
                                     'Z2_1':j, 
                                     'Z1_2':k,
                                     'Z2_2':l,
                                     'd1_1':d1_1_, 
                                     'd2_1':d2_1_,
                                     'd1_2':d1_2_,
                                     'd2_2':d2_2_,
                                     'i_1':j/i,
                                     'i_2':l/k, 
                                     'i_t':i_t_,
                                     'Erro [%]':error_,
                                     'Soma de dentes':Z_sum_,
                                     'a_1':a_1_,
                                     'a_2':a_2_}
                                     
                                opt_df = opt_df.append(r, ignore_index=True)

opt_df.sort_values('Erro [%]').head(15)



best_pair = opt_df.iloc[18]
best_pair

"""#### Deslocamento de perfil
**Engrenamento em Vê Zero**

$v = h_{ac} - r sin²\alpha$

$h_{ac} = K*m$

$x_{min} = K - {Z\over2}sin²\alpha$
"""

K = 1 + c
h_ac = K * best_pair['modulo']
v = h_ac - (best_pair['d1_1']/2)*np.sin(alpha)**2
x_min = K - (best_pair['Z1_1']*np.sin(alpha)**2)/2

print('Altura de adendo:\t\t{}'.format(h_ac))
print('Deslocamento v: \t\t{}'.format(v))
print('Fator mínimo de deslocamento:\t{}'.format(x_min))

"""Para viabilizar a fabricação escolhe-se um deslocamento v maior do que o obtido. Como esse valor pode ser arbitrário, escolhe-se um deslocamento de $0.2mm$. Como consequência, temos que o novo $x$ é $0.05$ como definido abaixo:"""

x = 0.2/best_pair['modulo']
print('Novo fator de deslocamento: {}'.format(x))

"""**Novas alturas de adendo e dedendo**

$h_{a1} = (1 + x_1)*m$

$h_{a2} = (1 + x_2)*m$

$h_{f1} = (1 + c - x_1)*m$

$h_{f2} = (1 + c - x_2)*m$

## Parte mecânica

Os cálculos apresentados a seguir baseiam-se na falha por flexão no dente. O Método utilizado será o **ISO 6336-3** de 2006.

Tensão máxima de flexão no pé do dente o valor:

> $\sigma_F = \sigma_{F0} K_A K_v K_{F\beta} K_{F\alpha} $

Sendo: 

* **$\sigma_F$** o valor admissível para tensão de flexão no pé do dente. 

* **$K_A$** O fator de aplicação.

* **$K_v$** O fator interno dinâmico (definido pela ISO 6336-1), é função dos efeitos do grau de precisão do dente em relação a velocidade e carga, sendo portanto influenciado pelo projeto e pela fabricação. A determinação do seu valor é mostrado no na seção sobre tensão superficial.

* **$K_{F\beta}$**  é o fator de carga na face, que considera a não uniformidade da superfície do dente (definido pela ISO 6336-1) e demonstrado na seção H.5.

* **$K_{F\alpha}$** é o fator de carga transversal na face, similar ao KF β mas na direção transversal para engrenagens helicoidais (definido também pela ISO 6336-1).

* **$\sigma_{F0}$** a tensão de flexão no pé do dente para um torque estático nominal, admitindo um contato livre de erros entre os dentes do par de engrenagens, pode ser calculado da seguinte forma:


> $\sigma_{F0} = {F_t\over b m_n} Y_F Y_S Y_\beta Y_B Y_{DT}$

Onde,

* $F_t$ carga tangente nominal, que produz efetivamente o torque

* $b$ a largura da engrenagem 

* $m_n$ o módulo na direção normal 

* $Y_F$ o fator de forma

* $Y_S$ o fator de correção de tensão

* $Y_β$ o fator de ângulo de hélice

* $Y_B$ o fator de espessura do aro 

* $Y_{DT}$ o fator de profundidade do dente
"""

x1, x2 = x, -x

# Altura de adendo
h_a1 = (1 + x1) * best_pair['modulo']
h_a2 = (1 + x2) * best_pair['modulo']

# Altura de dedendo
h_f1 = (1 + c - x1) * best_pair['modulo']
h_f2 = (1 + c - x2) * best_pair['modulo']

print('Altura do Adendo: {}'.format(h_a1))

"""---------------------
**T.H.E E.N.D**



Na próxima célula é definida uma função que recebe o diametro do pinhão e coroa de dois pares de engrenagens. Também recebe qual a relação de transmissão que se deseja atingir.

A função calcula o numero de dentes de cada engrenagem para todos os módulos padronizados de classe I.

Depois de calcular os numeros de dentes a função arredonda os valores obtidos e calcula a relação de transmissão, depois disso a função compara com a relação de transimissão que se deseja atingir e salva os resultados obtidos.

A função retorna uma tabela (DataFrame)com todos os resultados obtidos
"""

def iterate_diameters(d1_1, d2_1, d1_2, d2_2, i_t):

    # Module class I (for general purpouse)
    m = [0.3, 0.4, 0.5, 0.6, 0.8, 1, 1.25, 1.5, 2, 2.5,
         3, 4, 5, 6, 8, 10, 12, 20, 25, 32, 40, 50]

    # Create a DataFrame to hold the results
    df = pd.DataFrame(columns=['modulo', 'Z_pinhao_1','Z_coroa_1',
                                         'Z_pinhao_2', 'Z_coroa_2'])
    # Itereate over the modulus
    for m in m:
        # Compute the gear teeth for the given diameters
        z1_1 = d1_1/m
        z2_1 = d2_1/m
        z1_2 = d1_2/m
        z2_2 = d2_2/m

        df = df.append({'modulo':m,
                        'Z_pinhao_1': np.round(z1_1),
                        'Z_coroa_1': np.round(z2_1),
                        'Z_pinhao_2': np.round(z1_2),
                        'Z_coroa_2': np.round(z2_2)}, ignore_index=True)
    
    # Calculate the gear ratio
    df['i_1'] = df['Z_coroa_1']/df['Z_pinhao_1']
    df['i_2'] = df['Z_coroa_2']/df['Z_pinhao_2']
    df['i_t'] = df['i_1'] * df['i_2']
    
    # Calculate the difference between desired gear ratio and the calculated
    df['erro'] = df['i_t'] - i_t
    df['erro [%]'] = np.abs(df['erro']/i_t)

    return df.sort_values(by='erro [%]', ascending=True)

"""Agora chama-se a função definida anteriomente

*Obs.: Somente as 5 primeiras linhas da tabela estão apresentadas*
"""

iterate_diameters(d1_1, d2_1, d1_2, d2_2, i_t).head()

"""O próximo passo é gerar um conjunto com todos as combinações de diametros que satisfaçam a condição da distância entre eixos."""

pairs = zip(range(1, a), range(2*a-1, a, -1))

# Generates a list of lists with all combinations of pair of
# gears with a difference of 1mm
diameters = []
for i, j in pairs:
    diameters = diameters + [[i, j]]

# Create a DataFrame to hold the results
search_space = pd.DataFrame(columns=['d_pinhao_1', 'd_coroa_1',
                                     'd_pinhao_2','d_coroa_2'])

# Genereates a DataFrame with all combinations of diameters for 2 pairs
for first in diameters: 
    for second in diameters:  
        search_space = search_space.append({'d_pinhao_1': first[0], 
                                            'd_coroa_1': first[1],
                                            'd_pinhao_2': second[0],
                                            'd_coroa_2': second[1]},
                                            ignore_index=True)

# Search space size
search_size = search_space.shape
search_size

"""Dado que o espaço de busca é muito grande, na próxima célula reduzimos o espaço deixando no conjunto somente as configurações que possuem uma relação de transmissão próxima à desejada."""

# Create a DataFrame to hold the results
reduced_space = pd.DataFrame(columns=['d_pinhao_1', 'd_coroa_1',
                                      'd_pinhao_2','d_coroa_2'])
for i in range(search_size[0]):
    config = search_space.iloc[i]
    i_t_test = (config[1]/config[0])*(config[3]/config[2])
    if np.abs(i_t-i_t_test)<i_t_error:
        reduced_space = reduced_space.append(config)

# Reduced search space size
reduced_size = reduced_space.shape
reduced_size

# Create a DataFrame to hold the results
final_solutions = pd.DataFrame(columns=['modulo', 
                                        'd_pinhao_1', 'd_coroa_1',
                                        'd_pinhao_2', 'd_coroa_2',
                                        'Z_pinhao_1', 'Z_coroa_1', 
                                        'Z_pinhao_2', 'Z_coroa_2',
                                        'i_1', 'i_2', 'i_t',
                                        'erro', 'erro [%]'])

for solution in range(reduced_size[0]):
    diameteres = reduced_space.iloc[solution]
    
    # Get info about the configurations of the given diameters
    responses = iterate_diameters(diameteres[0], 
                                  diameteres[1], 
                                  diameteres[2], 
                                  diameteres[3], i_t=i_t)

    # Iterate over the first 20 configuration
    for i in range(20):
        r = responses.iloc[i]

        # boolean Series to verify if the Z are greater then Z_min
        tooth = r[1:5] > Z_min
        
        # Object to compare with tooth 
        test = pd.Series([True,True,True,True], index=tooth.index)

        # Verify the projects conditions
        if tooth.equals(test) and np.abs(r['erro [%]'])<0.01:
            answer = diameteres.append(r)
            final_solutions = final_solutions.append(answer, ignore_index=True)

final_solutions['inercia'] = final_solutions['d_pinhao_1']**2 + final_solutions['d_coroa_1']**2 + final_solutions['d_pinhao_2']**2 + final_solutions['d_coroa_2']**2
final_solutions['Z_sum'] = final_solutions['Z_pinhao_1'] + final_solutions['Z_coroa_1'] + final_solutions['Z_pinhao_2'] + final_solutions['Z_coroa_2']

final_solutions.sort_values(['modulo', 'Z_sum'], ascending=False).head(50)

tab_g2_index = pd.MultiIndex.from_arrays(
    [[6,6,7,7,8,8,9,9], 
    ['≤350','>350','≤350','>350','≤350','>350','≤350','>350']],
    names=('Grau de qualidade', 'Dureza superficial do dente'))

tab_g2_columns = pd.MultiIndex.from_tuples(
    [('Velocidade tangencial (m/s)','<1'),
     ('Velocidade tangencial (m/s)','1-3'),
     ('Velocidade tangencial (m/s)','3-8'),
     ('Velocidade tangencial (m/s)','8-12')])

tab_g2_data = [[None, None, 1.2,1.3],
                [None, None, 1.2,1.3],
                [None, 1.25,1.45,1.55],
                [None, 1.2,1.3,1.4],
                [None, 1.35,1.55, None],
                [1.0,1.3,1.4, None],
                [1.1,1.45, None, None],
                [1.1,1.4, None, None]]


tab_g2 = pd.DataFrame(data=tab_g2_data,
                      index=tab_g2_index,
                      columns=tab_g2_columns)

tab_g4_index = pd.Index([0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6],
                        name='Ψ') 
    
tab_g4_columns =pd.MultiIndex.from_tuples([
    ('Simétrica ao mancal',''),
    ('Assimétrica', 'Eixo muito rígido'),
    ('Assimétrica', 'Eixo pouco rígido'),
    ('Em balanço','')]) 

tab_g4_data = [
    [1.00, 1.00, 1.05, 1.15],
    [1.00, 1.04, 1.10, 1.22],
    [1.03, 1.08, 1.16, 1.32],
    [1.06, 1.13, 1.22, 1.45],
    [1.10, 1.18, 1.29],
    [1.14, 1.23, 1.36],
    [1.19, 1.29, 1.45],
    [1.25, 1.35, 1.55]]

tab_g4 = pd.DataFrame(data=tab_g4_data, 
                      index=tab_g4_index,
                      columns=tab_g4_columns)

tab_g5_index = pd.MultiIndex.from_tuples(
    [('Agitadores', 'Líquido puro'),
    ('Agitadores','Líquido e sólido'),
    ('Agitadores','Líquido dens. variável'),
    ('Bobinadores','Papel'),
    ('Bobinadores','Têxtil'),
    ('Compressores alternativos','Centrífugo'),
    ('Compressores alternativos','Lóbulos'),
    ('Compressores alternativos','Monocilindro'),
    ('Compressores alternativos','Multicilindro'),
    ('Geradores','Nao de solda'),
    ('Guinchos','Serviço médio'),
    ('Guinchos','Serviço pesado'),
    ('Guinchos','Dragas'),
    ('Máquinas operatrizes','Acionamento auxiliar'),
    ('Máquinas operatrizes','Acionamento principal'),
    ('Máquinas operatrizes','Rosqueadoras')],
)

tab_g5_columns = pd.MultiIndex.from_tuples([
    ('Serviço', '3 a 10h'),
    ('Serviço', '3 a 10h')])

tab_g5_data = [
   [1.0, 1.2],
   [1.25, 1.5],
   [1.25, 1.5],
   [1.0, 1.2],
   [1.25, 1.5],
   [1.00, 1.2],
   [1.25, 1.5],
   [1.75, 2.0],
   [1.25, 1.5],
   [1.00, 1.2],
   [1.25, 1.5],
   [1.75, 2.0],
   [1.25, 1.5],
   [1.00, 1.2],
   [1.25, 1.5],
   [1.75, 2.0]]

tab_g5 = pd.DataFrame(data=tab_g5_data, 
                      index=tab_g5_index,
                      columns=tab_g5_columns)

tab_g6_index = pd.Index([
    'Aços carbono e aços liga de média resistência',
    'Aços liga de grande resistência e dentes endurecidos',
    'FoFo cinzento',
    'FoFo maleável ou nodular'],
    name='Material')

tab_g6_columns = pd.Index(['Dureza', 'Tensão admissível (σHAdm) [MPa]'])

tab_g6_data = [
    ['< 350 HB','σHAdm = 2, 45 HB'],
    ['55 − 63 Rc','σHAdm = 24, 53 Rc'],
    ['170 − 270 HB','σHAdm = 1, 475 HB'],
    ['170 − 260 HB','σHAdm = 1, 776 HB']]

tab_g6 = pd.DataFrame(data=tab_g6_data, 
                      index=tab_g6_index,
                      columns=tab_g6_columns)

Material                                                    Dureza          Tensão admissível (σHAdm) [MPa]
'Aços carbono e aços liga de média resistência       '        < 350 HB        σHAdm = 2, 45 HB
'Aços liga de grande resistência e dentes endurecidos'        55 − 63 Rc      σHAdm = 24, 53 Rc
'FoFo cinzento                                       '        170 − 270 HB    σHAdm = 1, 475 HB
'FoFo maleável ou nodular                            '        170 − 260 HB    σHAdm = 1, 776 HB

tab_g6

